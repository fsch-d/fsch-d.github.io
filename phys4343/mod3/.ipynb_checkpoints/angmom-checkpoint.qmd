---
title: Orbital Angular Momentum in Quantum Mechanics
author: Daniel Fischer
#engine: python3
#jupyter: python3
---

# Orbital angular momentum: overview and plan

This chapter provides a comprehensive introduction to the quantum mechanical treatment of orbital angular momentum. We will derive the operators for angular momentum and solve the corresponding eigenvalue problem, which is fundamental to understanding the behavior of many quantum systems, including the hydrogen atom.

The specific goals for this chapter are:

1. Derive the quantum mechanical operator for orbital angular momentum, $\hat{\vec L}$, and analyze its key commutation relations.
2. Employ the method of separation of variables in spherical coordinates to transform the eigenvalue problem into a set of angular ordinary differential equations (ODEs).
3. Solve these ODEs to determine the quantized eigenvalues of $\hat L^2$ and its components, and find the corresponding eigenfunctions.

---

# 1. Angular Momentum in Cartesian Coordinates

In **classical mechanics**, the angular momentum is defined as the cross product
$$
\vec L = \vec r \times \vec p,
$$
with
$$
\vec r =
\begin{pmatrix}
x \\ y \\ z
\end{pmatrix},
\quad
\vec p =
\begin{pmatrix}
p_x \\ p_y \\ p_z
\end{pmatrix}.
$$

The cross product gives
$$
\vec L =
\begin{pmatrix}
L_x \\ L_y \\ L_z
\end{pmatrix}
=
\begin{pmatrix}
y p_z - z p_y \\
z p_x - x p_z \\
x p_y - y p_x
\end{pmatrix}.
$$

In **quantum mechanics**, we replace position and momentum by operators:

$$
\hat{\vec r} =
\begin{pmatrix}
\hat x \\ \hat y \\ \hat z
\end{pmatrix},
\qquad
\hat{\vec p} =
\begin{pmatrix}
\hat p_x \\ \hat p_y \\ \hat p_z
\end{pmatrix},
\qquad
\hat{\vec L} = \hat{\vec r} \times \hat{\vec p}.
$$

In the coordinate representation (position basis), we have

$$
\hat{\vec r} =
\begin{pmatrix}
x \\ y \\ z
\end{pmatrix},
\qquad
\hat{\vec p} =
-i\hbar
\begin{pmatrix}
\frac{\partial}{\partial x} \\
\frac{\partial}{\partial y} \\
\frac{\partial}{\partial z}
\end{pmatrix}.
$$

Therefore, the angular momentum operator is

$$
\hat{\vec L} =
\begin{pmatrix}
\hat L_x \\ \hat L_y \\ \hat L_z
\end{pmatrix}
=
-i\hbar
\begin{pmatrix}
y\frac{\partial}{\partial z} - z\frac{\partial}{\partial y} \\
z\frac{\partial}{\partial x} - x\frac{\partial}{\partial z} \\
x\frac{\partial}{\partial y} - y\frac{\partial}{\partial x}
\end{pmatrix}.
$$

---

## 1.1 Commutation Relations

From the canonical commutation relations
$$
[\hat x_i, \hat p_j] = i\hbar \,\delta_{ij}, 
\quad
[\hat x_i, \hat x_j] = 0,
\quad
[\hat p_i, \hat p_j] = 0,
$$
one can compute
$$
[\hat L_x, \hat L_y] = i\hbar \hat L_z, \qquad
[\hat L_y, \hat L_z] = i\hbar \hat L_x, \qquad
[\hat L_z, \hat L_x] = i\hbar \hat L_y.
$$

::: {.callout-note collapse="true"}
### Proof

The angular momentum components are
$$
\hat L_x = \hat y \hat p_z - \hat z \hat p_y, \qquad
\hat L_y = \hat z \hat p_x - \hat x \hat p_z, \qquad
\hat L_z = \hat x \hat p_y - \hat y \hat p_x.
$$

Compute the commutator:
$$
\begin{aligned}
{[\hat L_x, \hat L_y]} &= [\hat y \hat p_z - \hat z \hat p_y, \; \hat z \hat p_x - \hat x \hat p_z] \\
&= [\hat y \hat p_z, \hat z \hat p_x] 
- [\hat y \hat p_z, \hat x \hat p_z] 
- [\hat z \hat p_y, \hat z \hat p_x] 
+ [\hat z \hat p_y, \hat x \hat p_z].
\end{aligned}
$$

Expanding and using the canonical commutators $[\hat x_i, \hat p_j] = i\hbar \delta_{ij}$ and $[\hat x_i, \hat x_j] = [\hat p_i, \hat p_j] = 0$:

1. $[\hat y \hat p_z, \hat z \hat p_x] = \hat y [\hat p_z, \hat z] \hat p_x = -i\hbar \hat y \hat p_x$  
2. $-[\hat y \hat p_z, \hat x \hat p_z] = 0$  
3. $-[\hat z \hat p_y, \hat z \hat p_x] = 0$
4. $[\hat z \hat p_y, \hat x \hat p_z] = \hat x [\hat z, \hat p_z] \hat p_y = i\hbar \hat x \hat p_y$

Adding the nonzero terms gives
$$
[\hat L_x, \hat L_y] = i\hbar (\hat x \hat p_y - \hat y \hat p_x) = i\hbar \hat L_z.
$$

Thus the commutator is verified. The remaining commutators, $[\hat L_y, \hat L_z]$ and $[\hat L_z, \hat L_x]$, can be derived using the same method.


:::

These relations show:

::: {.callout-caution}
- The three components $\hat L_x, \hat L_y, \hat L_z$ **do not commute**.  
- Thus, there are **no eigenstates of the full vector operator** $\hat{\vec L}$.
:::


---

## 1.2 Total Angular Momentum

The squared operator is defined as
$$
\hat L^2 = \hat L_x^2 + \hat L_y^2 + \hat L_z^2.
$$

It satisfies
$$
[\hat L^2, \hat L_x] = [\hat L^2, \hat L_y] = [\hat L^2, \hat L_z] = 0.
$$

Hence, we can find simultaneous eigenstates of $\hat L^2$ and one component, usually chosen to be $\hat L_z$.


```{python}
#| label: fig-momentumvec
#| fig-format: svg
#| fig-cap: Momentum Eigenvector in Quantum Mechanics.
#| fig-alt: Momentum Eigenvector in Quantum Mechanics.
import matplotlib.pyplot as plt
import numpy as np

# Create a new figure and a 3D axis
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Set the aspect ratio to 'equal' for better visualization
ax.set_box_aspect([1,1,1])

# Define the components of the angular momentum vector L
Lx = 3
Ly = 4
Lz = 6

# The origin of the vectors
origin = [0, 0, 0]

# Plot the angular momentum vector L
ax.quiver(*origin, Lx, Ly, Lz, color='red', label=r'$\vec{L}$', arrow_length_ratio=0.15)

# Plot the z-component vector Lz
ax.quiver(*origin, 0, 0, Lz, color='blue', linestyle='--', arrow_length_ratio=0.1)

# Plot the x, y, and z unit vectors
ax.quiver(*origin, 1, 0, 0, color='gray', arrow_length_ratio=0.3)
ax.quiver(*origin, 0, 1, 0, color='gray', arrow_length_ratio=0.3)
ax.quiver(*origin, 0, 0, 1, color='gray', arrow_length_ratio=0.3)

# Add labels for the unit vectors
ax.text(1.2, 0, 0, 'x', color='gray', fontsize=12)
ax.text(0, 1.2, 0, 'y', color='gray', fontsize=12)
ax.text(0, 0, 1.2, 'z', color='gray', fontsize=12)

# Set title
# ax.set_title('Quantum Mechanical Angular Momentum Vector', fontsize=16)

# Plot the circle of possible endpoints for the L vector
radius = np.sqrt(Lx**2 + Ly**2)
theta = np.linspace(0, 2 * np.pi, 100)
x_circle = radius * np.cos(theta)
y_circle = radius * np.sin(theta)
z_circle = np.full_like(theta, Lz)
ax.plot(x_circle, y_circle, z_circle, color='green', linestyle=':', label='Uncertainty Circle')

# Add annotations for vector lengths, adjusted for better visibility
lambda_val = Lx**2 + Ly**2 + Lz**2
mu_val = Lz
ax.text(Lx * 0.7, Ly * 0.6, Lz * 0.4, r'$\sqrt{\lambda}$', color='red', fontsize=14, horizontalalignment='left')
ax.text(0.5, 0.5, Lz * 0.5, r'$\mu$', color='blue', fontsize=14, horizontalalignment='left')

# Set the plot limits
ax.set_xlim([-5, 5])
ax.set_ylim([-5, 5])
ax.set_zlim([0, 7])

# Remove background planes and main axes lines, but keep the specific unit vectors
ax.set_axis_off()

# Remove grid
ax.grid(False)

# Save the plot
#plt.savefig('angular_momentum_final.png')

plt.show()
```

---

# 2. Angular Momentum Operators in Spherical Coordinates

The angular momentum operators in position representation act on wavefunctions $\psi(r,\theta,\varphi)$, where $(r,\theta,\varphi)$ are spherical coordinates:

$$
x = r\sin\theta\cos\varphi, \quad
y = r\sin\theta\sin\varphi, \quad
z = r\cos\theta
$$

The derivatives transform as:

$$
\frac{\partial}{\partial x}, \frac{\partial}{\partial y}, \frac{\partial}{\partial z} \quad \rightarrow \quad \frac{\partial}{\partial r}, \frac{\partial}{\partial \theta}, \frac{\partial}{\partial \varphi}
$$

After some algebra (using the chain rule), the z-component simplifies nicely to:

$$
\hat{L}_z = -i\hbar \frac{\partial}{\partial \varphi}.
$$


The squared angular momentum operator also transforms to spherical coordinates. Using the spherical Laplacian $\nabla^2$ and the fact that $\hat{L}^2$ acts only on angular variables:

$$
\hat{L}^2 = -\hbar^2 \left[ \frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\!\Big(\sin\theta\frac{\partial}{\partial\theta}\Big)
+ \frac{1}{\sin^2\theta}\frac{\partial^2}{\partial\varphi^2} \right].
$$

We seek functions $Y(\theta,\varphi)$ that are simultaneous eigenfunctions:

$$
\hat{L}^2 Y(\theta,\varphi) = \lambda\, Y(\theta,\varphi), \qquad
\hat{L}_z Y(\theta,\varphi) = \mu\, Y(\theta,\varphi).
$$

---

# 3. Separation of Variables

We try the product form

$$
Y(\theta,\varphi)=\Theta(\theta)\,\Phi(\varphi).
$$

---

## 3.1 Eigenfunctions of $\hat{L}_z$

Applying $\hat{L}_z$ gives:

$$
\hat{L}_z Y = -i\hbar \frac{\partial}{\partial \varphi}(\Theta(\theta)\Phi(\varphi))
= -i\hbar \Theta(\theta) \frac{d\Phi}{d\varphi}.
$$

Thus $\Phi$ must satisfy:

$$
\frac{d\Phi}{d\varphi} = i m \Phi, \quad m \in \mathbb{Z}.
$$

The solutions are:

$$
\Phi(\varphi) = e^{im\varphi}, \qquad \mu = \hbar m.
$$

---

## 3.2 Equation for $\Theta(\theta)$

Substituting into the $\hat{L}^2$ eigenvalue equation:

$$
\frac{1}{\sin\theta}\frac{d}{d\theta}\!\Big(\sin\theta\frac{d\Theta}{d\theta}\Big)
- \frac{m^2}{\sin^2\theta}\Theta + \ell(\ell+1)\Theta = 0,
$$

where we have set $\lambda = \hbar^2 \ell(\ell+1)$.  

Let $x = \cos\theta$. Then the equation becomes:

$$
\frac{d}{dx}\Big[(1-x^2)\frac{dP}{dx}\Big] + \Big[\ell(\ell+1) - \frac{m^2}{1-x^2}\Big] P(x) = 0.
$$

This is the **associated Legendre equation**. The physically acceptable solutions to this equation are the **associated Legendre functions**, $P_\ell^m(x)$ , which are defined in terms of the standard **Legendre polynomials** $P_\ell(x)$:

$$
P_\ell^m(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_\ell(x).
$$

The Legendre polynomials $P_\ell(x)$ can be constructed explicitly as (Rodrigues' Formula):

$$
P_\ell(x) = \frac{1}{2^\ell \ell!} \frac{d^\ell}{dx^\ell} \big[(x^2-1)^\ell\big].
$$


---
## 3.3 General result

::: {.callout-tip}
## General Form of Spherical Harmonics

Combining both angular parts, the eigenfunctions are:

$$
Y_\ell^m(\theta,\varphi) = N_{\ell m}\, P_\ell^m(\cos\theta)\, e^{i m \varphi},
$$

with normalization constant

$$
N_{\ell m} = (-1)^m \sqrt{\frac{2\ell+1}{4\pi}\,\frac{(\ell-m)!}{(\ell+m)!}}.
$$
:::

::: {.callout-tip}
## Eigenvalue Equations

The spherical harmonics satisfy:

$$
\hat{L}^2 Y_{\ell}^{m} = \hbar^2 \ell(\ell+1) Y_{\ell}^{m}, \qquad
\hat{L}_z Y_{\ell}^{m} = \hbar m Y_{\ell}^{m}.
$$

Thus $Y_\ell^m$ are simultaneous eigenfunctions of both $\hat{L}^2$ and $\hat{L}_z$.
:::


::: {.callout-tip}
## Orthonormality

The spherical harmonics satisfy:

$$
\int_0^{2\pi}\!\int_0^\pi Y_\ell^m(\theta,\varphi)^*\,Y_{\ell'}^{m'}(\theta,\varphi)\,
\sin\theta \, d\theta\, d\varphi
= \delta_{\ell\ell'}\delta_{mm'}.
$$

Thus, $\{Y_\ell^m\}$ forms a complete orthonormal basis for functions on the sphere.
:::

---

# 4. Quantization of $\ell$ and $m$

The requirement that the eigenfunctions be single-valued and finite on the sphere leads to restrictions on $\ell$ and $m$.

- From the $\varphi$-dependence:  
  The solution is $\Phi(\varphi) = e^{i m \varphi}$.  
  For this to be single-valued when $\varphi \to \varphi + 2\pi$, we must have  
  $$
  e^{i m (\varphi + 2\pi)} = e^{i m \varphi}.
  $$
  This holds only if $m \in \mathbb{Z}$ (an integer).  
  Thus, the magnetic quantum number $m$ is an integer.

- From the $\theta$-dependence:  
  The function $\Theta(\theta)$ must be finite at the poles ($\theta=0,\pi$).  
  This condition restricts the separation constant to the form  
  $$
  \lambda = \hbar^2 \ell(\ell+1),
  $$
  with $\ell = 0, 1, 2, \dots$.  
  If $\ell$ were not an integer, the associated Legendre functions $P_\ell^m(\cos\theta)$ would diverge or fail to be single-valued.  
  Thus, the orbital quantum number $\ell$ must be a non-negative integer.

- For each $\ell$, the allowed $m$ values are integers satisfying $-\ell \le m \le \ell$.  
  This ensures that the associated Legendre functions $P_\ell^m(\cos\theta)$ remain well-defined and normalizable.

Therefore, we obtain:

::: {.callout-tip}
## Quantization rules
$$
\ell = 0, 1, 2, \dots, \qquad m = -\ell, -\ell+1, \dots, \ell-1, \ell.
$$

The $\theta$-dependence is given explicitly by the **associated Legendre functions** $P_\ell^m(\cos\theta)$.
:::


---

# 5. Ladder Operators and $m$-States

To understand the structure of the angular momentum eigenstates, it is useful to introduce the **ladder operators**:

$$
\hat{L}_\pm = \hat{L}_x \pm i \hat{L}_y.
$$

These operators act on the eigenstates $\lvert \ell, m \rangle$ (in Dirac notation, see [below](#sec-Diracangmom)) of $\hat{L}^2$ and $\hat{L}_z$ in the following way:

$$
\hat{L}_\pm \lvert \ell, m \rangle 
= \hbar \sqrt{\ell(\ell+1) - m(m \pm 1)} \, \lvert \ell, m \pm 1 \rangle.
$$

(For mathematical proof see [appendix](#sec-ladderproof)) <!-- or [appendix @sec-ladderproof]) -->

---

## 5.1 Key observations

- $\hat{L}_+$ raises $m$ by one unit:  
  $\; m \mapsto m+1$.

- $\hat{L}_-$ lowers $m$ by one unit:  
  $\; m \mapsto m-1$.

- Since the maximum value of $m$ is $\ell$, applying $\hat{L}_+$ to $\lvert \ell, \ell \rangle$ gives zero:  

  $$
  \hat{L}_+ \lvert \ell, \ell \rangle = 0.
  $$

- Similarly, $L_-$ annihilates the lowest state $\lvert \ell, -\ell \rangle$:  

  $$
  \hat{L}_- \lvert \ell, -\ell \rangle = 0.
  $$

- The ladder operators explain why the possible $m$ values for a fixed $\ell$ are restricted to integers in the range $-\ell, -\ell+1, \dots, \ell - 1, \ell$:

  - Starting from the top state $\lvert \ell, \ell \rangle$, repeated applications of $\hat{L}_-$ generate all the states down to $\lvert \ell, -\ell \rangle$.  
  - No other values of $m$ appear, because outside this range the ladder action vanishes.

---

## 5.2 Connection to spherical harmonics

In the coordinate-space representation, these ladder operators correspond to differential operators acting on the spherical harmonics $Y_\ell^m(\theta,\varphi)$:

$$
\hat{L}_\pm Y_\ell^m(\theta,\varphi) 
= \hbar \sqrt{\ell(\ell+1) - m(m \pm 1)} \, Y_\ell^{m\pm 1}(\theta,\varphi).
$$

This provides an algebraic way to generate all spherical harmonics of a given $\ell$ starting from the “highest-weight” function $Y_\ell^\ell(\theta,\varphi)$.

---

# 6. Explicit Examples

For the lowest values of $\ell$ and $m$, the normalized spherical harmonics are:

- $\ell=0, m=0$:
  $$
  Y_0^0 = \sqrt{\frac{1}{4\pi}}.
  $$

- $\ell=1$:
  $$
  Y_1^0 = \sqrt{\frac{3}{4\pi}} \cos\theta,
  $$
  $$
  Y_1^{\pm 1} = \mp \sqrt{\frac{3}{8\pi}} \sin\theta \, e^{\pm i\varphi}.
  $$

- $\ell=2$:
  $$
  Y_2^0 = \sqrt{\frac{5}{16\pi}} (3\cos^2\theta - 1),
  $$
  $$
  Y_2^{\pm 1} = \mp \sqrt{\frac{15}{8\pi}} \sin\theta \cos\theta \, e^{\pm i\varphi},
  $$
  $$
  Y_2^{\pm 2} = \sqrt{\frac{15}{32\pi}} \sin^2\theta \, e^{\pm 2i\varphi}.
  $$

These functions form the familiar $s$, $p$, and $d$ orbitals in atomic physics.

```{python}
#| label: fig-sphericalh
#| fig-format: svg
#| fig-cap: Absolute square of some spherical harmonics in 3D polar plot.
#| fig-alt: Absolute square of some spherical harmonics in 3D polar plot.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def complex_spherical_harmonics_squared(l, m, theta, phi):
    """
    Calculates the absolute square of the normalized complex spherical harmonic Y_l^m(theta, phi).

    Args:
        l (int): The orbital quantum number.
        m (int): The magnetic quantum number.
        theta (numpy.ndarray): The polar angle (from 0 to pi).
        phi (numpy.ndarray): The azimuthal angle (from 0 to 2*pi).

    Returns:
        numpy.ndarray: The value of |Y_l^m(theta, phi)|^2.
    """
    if l == 0 and m == 0:
        return np.full_like(theta, 1.0 / (4.0 * np.pi))
    elif l == 1:
        if m == 0:
            return (3.0 / (4.0 * np.pi)) * np.cos(theta)**2
        elif abs(m) == 1:
            # The e^(i*phi) term squared has a magnitude of 1, so we only
            # need to square the sine term and the prefactor.
            return (3.0 / (8.0 * np.pi)) * np.sin(theta)**2
    elif l == 2:
        if m == 0:
            return (5.0 / (16.0 * np.pi)) * (3.0 * np.cos(theta)**2 - 1.0)**2
        elif abs(m) == 1:
            return (15.0 / (8.0 * np.pi)) * (np.sin(theta) * np.cos(theta))**2
        elif abs(m) == 2:
            return (15.0 / (32.0 * np.pi)) * np.sin(theta)**4
    else:
        # Return zeros for any other (l,m) pairs not explicitly handled.
        return np.zeros_like(theta)

# Set up the spherical coordinate grid
theta_phi_samples = 100
theta = np.linspace(0, np.pi, theta_phi_samples)
phi = np.linspace(0, 2 * np.pi, theta_phi_samples)
theta, phi = np.meshgrid(theta, phi)

# Define the (l, m) pairs to be plotted, avoiding redundant plots
# We only need to plot for m >= 0
lm_pairs = [
    (0, 0),
    (1, 0), (1, 1),
    (2, 0), (2, 1), (2, 2)
]

# Calculate the squared magnitude for all spherical harmonics and find the global maximum
all_R_values = []
for l, m in lm_pairs:
    R = complex_spherical_harmonics_squared(l, m, theta, phi)
    all_R_values.append(R)

# Find the global maximum to normalize all plots to the same scale
R_max = max(np.max(r) for r in all_R_values)

# Set up the plot with a grid of subplots (2 rows, 3 columns)
fig = plt.figure(figsize=(7, 4.67))

# Loop through the pairs and create a subplot for each
for i, (l, m) in enumerate(lm_pairs):
    ax = fig.add_subplot(2, 3, i + 1, projection='3d')
    # Set equal aspect ratio for the plot box
    ax.set_box_aspect([1, 1, 1])

    # Get the pre-calculated R and normalize it
    R = all_R_values[i] / np.max(all_R_values[i])#R_max
    if (l,m)==(0,0): R = R/1.5

    # Convert to Cartesian coordinates for plotting
    x = R * np.sin(theta) * np.cos(phi)
    y = R * np.sin(theta) * np.sin(phi)
    z = R * np.cos(theta)

    # Normalize the R values for color mapping and apply alpha
    norm = plt.Normalize(vmin=R.min(), vmax=R.max())
    if (l,m)==(0,0): norm = plt.Normalize(vmin=R.min()-.1, vmax=R.max()+.1)
    colors = plt.cm.jet(norm(R))
    
    # Plot the surface with colors based on the radius and alpha set directly
    ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=colors,
                    edgecolor='none', alpha=0.8)
    
    # Plot the surface, with a solid, uniform color to better show shape
#    ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis',
#                    edgecolor='none', alpha=0.8)
    
    
    # Manually set the axis limits to be identical across all plots
    ax.set_xlim([-1, 1])
    ax.set_ylim([-1, 1])
    ax.set_zlim([-1, 1])

    # Set titles for each subplot, using the pm symbol where appropriate
    if m == 0:
        title = r'$|Y_{' + str(l) + '}^0|^2$'
    else:
        title = r'$|Y_{' + str(l) + '}^{\pm ' + str(m) + '}|^2$'
    ax.set_title(title, fontsize=14)

    # Hide the axes to make the plot cleaner
    ax.set_axis_off()

plt.tight_layout()
plt.show()
```

---

# 7. Dirac notation {#sec-Diracangmom}

In **Dirac notation**, we can label the angular momentum eigenstates as $\lvert \ell, m \rangle$.  

This reminds us that the spherical harmonics $Y_\ell^m(\theta,\varphi)$ are simply the coordinate-space representation of the abstract states $\lvert \ell, m \rangle$:

$$
Y_\ell^m(\theta,\varphi) = \langle \theta, \varphi \,|\, \ell, m \rangle.
$$

Hence, the two notations are fully consistent:  
- The **wavefunction view** uses functions on the sphere $Y_\ell^m(\theta,\varphi)$.  
- The **operator view** uses abstract eigenstates $\lvert \ell, m \rangle$. 


::: {.callout-tip}
## Important

The orthonormality relation then reads:

$$
\langle \ell, m \,|\, \ell', m' \rangle = \delta_{\ell\ell'} \, \delta_{mm'}.
$$

The eigenvalue equations are:


$$
\boxed{\;
\hat{L}^2 \lvert \ell, m \rangle = \hbar^2 \ell(\ell+1) \lvert \ell, m \rangle, \qquad
\hat{L}_z \lvert \ell, m \rangle = \hbar m \lvert \ell, m \rangle
\;}
$$

with the quantum numbers

$$
\ell = 0, 1, 2, \dots, \qquad m = -\ell, -\ell+1, \dots, \ell-1, \ell.
$$

:::

---

# Appendix: Proof of the Ladder Operator Action {#sec-ladderproof}

To justify the standard formulas for the action of the ladder operators on angular momentum eigenstates, let us derive them step by step.

---

## Step 1: Definitions and commutators

Define the ladder operators
$$
\hat L_\pm = \hat L_x \pm i \hat L_y.
$$

They satisfy the commutation relations
$$
[\hat L_z, \hat L_\pm] = \pm \hbar \hat L_\pm, 
\qquad
[\hat L_+, \hat L_-] = 2\hbar \hat L_z.
$$

Thus, if $\hat L_z \lvert \ell,m \rangle = \hbar m \lvert \ell,m \rangle$, then
$$
\hat L_z(\hat L_\pm \lvert \ell,m \rangle) 
= (\hbar m \pm \hbar)\, \hat L_\pm \lvert \ell,m \rangle.
$$

::: {.callout-note collapse="true"}
## Proof

The commutator of $\hat L_z$ with the ladder operators is

$$
[\hat L_z, \hat L_\pm] 
= [\hat L_z, \hat L_x] \pm i [\hat L_z, \hat L_y] 
= i \hbar \hat L_y \pm \hbar \hat L_x 
= \pm \hbar (\hat L_x \pm i \hat L_y) 
= \pm \hbar \hat L_\pm .
$$

From this relation we obtain the operator identity

$$
\hat L_z \hat L_\pm 
= [\hat L_z, \hat L_\pm] + \hat L_\pm \hat L_z 
= \pm \hbar \hat L_\pm + \hat L_\pm \hat L_z 
= \hat L_\pm(\hat L_z \pm \hbar).
$$

Thus, when acting on an eigenstate $\lvert \ell, m \rangle$ of $\hat L^2$ and $\hat L_z$, the operator $\hat L_\pm$ shifts the magnetic quantum number by one unit:

$$
\hat L_z \, (\hat L_\pm \lvert \ell, m \rangle) 
= (m \pm 1)\hbar \, (\hat L_\pm \lvert \ell, m \rangle).
$$


:::


This shows that $\hat L_\pm$ (if nonzero) produces another eigenstate with eigenvalue $m \pm 1$.  
So we may write
$$
\hat L_\pm \lvert \ell,m \rangle = C_\pm(\ell,m) \lvert \ell, m \pm 1 \rangle,
$$
for some coefficient $C_\pm(\ell,m)$.

---

## Step 2: Determining $|C_\pm|^2$

Consider the squared norm:
$$
\|\hat L_+ \lvert \ell,m \rangle \|^2 
= \langle \ell,m | \hat L_- \hat L_+ | \ell,m \rangle.
$$

Using the operator identity
$$
\hat L_- \hat L_+ = \hat L^2 - \hat L_z^2 - \hbar \hat L_z,
$$
and the eigenvalue equations
$$
\hat L^2 \lvert \ell,m \rangle = \hbar^2 \ell(\ell+1) \lvert \ell,m \rangle, 
\qquad
\hat L_z \lvert \ell,m \rangle = \hbar m \lvert \ell,m \rangle,
$$
we get
$$
\|\hat L_+ \lvert \ell,m \rangle \|^2
= \hbar^2 \big(\ell(\ell+1) - m(m+1)\big).
$$

Thus,
$$
|C_+(\ell,m)|^2 = \hbar^2 \big(\ell(\ell+1) - m(m+1)\big).
$$

Similarly, using
$$
\hat L_+ \hat L_- = \hat L^2 - \hat L_z^2 + \hbar \hat L_z,
$$
we find
$$
|C_-(\ell,m)|^2 = \hbar^2 \big(\ell(\ell+1) - m(m-1)\big).
$$

---

## Step 3: Fixing the phase convention

We can choose the overall phase of the eigenstates such that $C_\pm$ are real and positive. With this standard convention we obtain:

$$
\hat L_+ \lvert \ell,m \rangle 
= \hbar \sqrt{\ell(\ell+1) - m(m+1)} \; \lvert \ell,m+1 \rangle,
$$

$$
\hat L_- \lvert \ell,m \rangle 
= \hbar \sqrt{\ell(\ell+1) - m(m-1)} \; \lvert \ell,m-1 \rangle.
$$

---

**Conclusion:**  
The ladder operators raise or lower the $m$ quantum number by one unit, with the above coefficients.


